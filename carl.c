
#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Reflected) // We need to set colour Sensor to reflected light
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//=================== Basic Mathematics =================================
/*
Specifications of Robot:
Diameter of Rotation circle: 12.3 cm
Diameter of Wheel: 5.655 cm
Circumference of Rotation Circle: 38.64158964 cm
Circumference of Wheel: 17.76570646 cm
Revs in Rotation Circle: 2.175066313 revs (wheels)
Revs in 90 degree rotation: 0.5437665781 revs (wheels)
*/
//=======================================================================

//=================== Global Variables ==================================

// DEFAULLTS
#define DEFAULT_SPD 30           // default ev3 robot speed.
#define OFFSET      23           // offset for revs user defined encoded movements.
#define REV_90      0.5437665781 // exact revolutions for ev3 robot for 90 degrees.
#define REV_360     2.175066313  // exact revolutions for ev3 robot for 360 degrees.
#define SAMPLES     2         // the maximum samples we can obtain.

#define SMALL_TILE_DISTANCE 0.56 // Need to define. Based on 10cm tile

/*
Motor Functions 
Method used to tell both wheels to turn certain revs.
*/
void reset_motors(){
  setMotorSpeed(motorB, 0);
  setMotorSpeed(motorC, 0);
  sleep(10);
}

/*
  Method used to reset the motor encoder (turn) values.
*/
void reset_mencoder(){
  resetMotorEncoder(motorB);
  resetMotorEncoder(motorC);
}

void encoded_mforward(float revs, long pow){
  float revs_to_degs = revs * 360;
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, 0, revs_to_degs, pow);
  while(getMotorEncoder(motorB) <= revs_to_degs) {}
}

/*
  Method for pivot left given a rev and pow. 
*/
void encoded_lpivot(float revs, long pow){
  float revs_to_degs = (revs * 360 - OFFSET);
  displayCenteredBigTextLine(4, "Rotating Left");
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, -100, revs_to_degs, pow);
  while(getMotorEncoder(motorC) <= revs_to_degs) {}
  eraseDisplay();
}

/*
  Method for pivoting right given a rev and pow.
*/
void encoded_rpivot(float revs, long pow){
  float revs_to_degs = (revs * 360 - OFFSET);
  displayCenteredBigTextLine(4, "Rotating Right");
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, 100, revs_to_degs, pow);
  while(getMotorEncoder(motorB) <= revs_to_degs) {

  }
  eraseDisplay();
}



// main task
task main(){

  int tileCount = 1;
  int blackCount = 0;
  bool onBlack = true; // Set to tree as start on black tile
  bool onTrack = false; // can set to true to test second if
  bool hasRotated = false; // can set to true to test second if
  
  short currentColour; // color from sensor

  while (true){

      // These are only both false at start of demo
      if(!onTrack && !hasRotated) {
        encoded_mforward(0.62, 50);
        encoded_rpivot(REV_90, 30);
        onTrack = true;
        hasRotated = true;
      }

      // This equals true after first rotation, beginning of track
      if(onTrack && hasRotated) { 
        // This equals true after first rotation
        // Count the number of rotations to determine if we are on blackTile or White
        while(tileCount > 30){

          encoded_mforward(SMALL_TILE_DISTANCE, 50);
          currentColour = SensorValue[Colour];

          // When on White tile
          if(tileCount % 2 == 0){
            if(currentColour < 40){
                displayCenteredBigTextLine(4,"Expecting White, found grey");
                break;
            }            
          }

          // When on black tile
          else{
            if(currentColour > 15){
                displayCenteredBigTextLine(4,"Expecting Black, found grey");
                break;
            }
            else{
              blackCount++;
              playTone(200,20);
            }
          }
          tileCount++;          
        }
        onTrack = false;
        sleep(100); // Wait 100 ms to get 20 readings per second
      }
      // This is after second rotation
      if(!on_track && hasRotated) {
            encoded_rpivot(REV_90, 30);
      }
   }
}