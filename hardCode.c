#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//=================== Basic Mathematics =================================
/*
Specifications of Robot:
Diameter of Rotation circle: 12.3 cm
Diameter of Wheel: 5.655 cm
Circumference of Rotation Circle: 38.64158964 cm
Circumference of Wheel: 17.76570646 cm
Revs in Rotation Circle: 2.175066313 revs (wheels)
Revs in 90 degree rotation: 0.5437665781 revs (wheels)
*/
//=======================================================================

//=================== Global Variables ==================================

// DEFAULLTS
#define DEFAULT_SPD 40           // default ev3 robot speed.
#define OFFSET      30           // offset for revs user defined encoded movements.
#define REV_90      0.5437665781 // exact revolutions for ev3 robot for 90 degrees.
#define REV_360     2.175066313  // exact revolutions for ev3 robot for 360 degrees.
#define SAMPLES     2         // the maximum samples we can obtain.

#define black_threshold		15
#define white_threshold 	40
#define SMALL_TILE_DISTANCE 0.6 // Need to define. Based on 10cm tile

/* Motor Functions  Method used to tell both wheels to turn certain revs. */
void reset_motors(){
  setMotorSpeed(motorB, 0);
  setMotorSpeed(motorC, 0);
  sleep(10);
}
/* Method used to reset the motor encoder (turn) values. */
void reset_mencoder(){
  resetMotorEncoder(motorB);
  resetMotorEncoder(motorC);
}
/* Method for move forward given n of rotations */
void encoded_mforward(float revs, long pow){
  float revs_to_degs = revs * 360;
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, 0, revs_to_degs, pow);
  while(getMotorEncoder(motorB) < revs_to_degs) {}
}

/* Method for pivot left given a rev and pow. */
void encoded_lpivot(float revs, long pow){
  float revs_to_degs = (revs * 360 - OFFSET);
  displayCenteredBigTextLine(4, "Rotating Left");
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, -100, revs_to_degs, pow);
  while(getMotorEncoder(motorC) < revs_to_degs) {}
  //eraseDisplay();
}

/*
  Method for pivoting right given a rev and pow.
*/
void encoded_rpivot(float revs, long pow){
  float revs_to_degs = (revs * 360 - OFFSET);
  //displayCenteredBigTextLine(4, "Rotating Right");
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, 100, revs_to_degs, pow);
  while(getMotorEncoder(motorC) >= -revs_to_degs) {
  	//displayCenteredTextLine(2, "left: %f", getMotorEncoder(motorB));
  	//displayCenteredTextLine(4, "cur val: %f", revs_to_degs);
		//displayCenteredTextLine(6, "right: %f", getMotorEncoder(motorC));
  }
  	//displayCenteredTextLine(2, "left: %f", getMotorEncoder(motorB));
  	//displayCenteredTextLine(4, "cur val: %f", revs_to_degs);
		//displayCenteredTextLine(6, "right: %f", getMotorEncoder(motorC));
 // eraseDisplay();
}

/* Move forward specific rotations, check for black */
void on_track(){

	int revs = (30*SMALL_TILE_DISTANCE+3);
	float revs_to_degs = revs * 360;
	bool on_black = false;
	int cur_clr = 0;
	int black_count = 0;

  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, 0, revs_to_degs, DEFAULT_SPD);

	while(getMotorEncoder(motorB) < revs_to_degs && black_count < 15)
	{
		cur_clr = SensorValue[Colour];

		if(cur_clr == 1)
		{
			if(!on_black)
			{
				on_black = true;
				//displayCenteredBigTextLine(4, "%d", ++black_count);
				playTone(700, 10);
			}
		} else on_black = false;
	}

	reset_mencoder();
}

task main(){
	/* Initial Stage */
	encoded_mforward(0.66, DEFAULT_SPD);
	sleep(100);
	encoded_rpivot(REV_90, 20);

  /* After Initial Pivot */
  on_track();

  /* After second pivot */
	//encoded_rpivot(REV_90, DEFAULT_SPD);
  //encoded_mforward(SMALL_TILE_DISTANCE * 4, DEFAULT_SPD);
}
