
#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Reflected) // We need to set colour Sensor to reflected light
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//=================== Basic Mathematics =================================
/*
Specifications of Robot:
Diameter of Rotation circle: 12.3 cm
Diameter of Wheel: 5.655 cm
Circumference of Rotation Circle: 38.64158964 cm
Circumference of Wheel: 17.76570646 cm
Revs in Rotation Circle: 2.175066313 revs (wheels)
Revs in 90 degree rotation: 0.5437665781 revs (wheels)
*/
//=======================================================================

//=================== Global Variables ==================================

// DEFAULLTS
#define DEFAULT_SPD 30           // default ev3 robot speed.
#define OFFSET      23           // offset for revs user defined encoded movements.
#define REV_90      0.5437665781 // exact revolutions for ev3 robot for 90 degrees.
#define REV_360     2.175066313  // exact revolutions for ev3 robot for 360 degrees.
#define SAMPLES     2         // the maximum samples we can obtain.

#define SMALL_TILE_DISTANCE 0.56 // Need to define. Based on 10cm tile

/* Motor Functions  Method used to tell both wheels to turn certain revs. */
void reset_motors(){
  setMotorSpeed(motorB, 0);
  setMotorSpeed(motorC, 0);
  sleep(10);
}
/* Method used to reset the motor encoder (turn) values. */
void reset_mencoder(){
  resetMotorEncoder(motorB);
  resetMotorEncoder(motorC);
}
/* Method for move forward given n of rotations */
void encoded_mforward(float revs, long pow){
  float revs_to_degs = revs * 360;
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, 0, revs_to_degs, pow);
  while(getMotorEncoder(motorB) <= revs_to_degs) {}
}

/* Method for pivot left given a rev and pow. */
void encoded_lpivot(float revs, long pow){
  float revs_to_degs = (revs * 360 - OFFSET);
  displayCenteredBigTextLine(4, "Rotating Left");
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, -100, revs_to_degs, pow);
  while(getMotorEncoder(motorC) <= revs_to_degs) {}
  eraseDisplay();
}

/*
  Method for pivoting right given a rev and pow.
*/
void encoded_rpivot(float revs, long pow){
  float revs_to_degs = (revs * 360 - OFFSET);
  displayCenteredBigTextLine(4, "Rotating Right");
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, 100, revs_to_degs, pow);
  while(getMotorEncoder(motorB) <= revs_to_degs) {

  }
  eraseDisplay();
}

/* Move forward specific rotations, and rotate right */
void initial_move(){
    encoded_mforward(0.62, 50);
    encoded_rpivot(REV_90, 50);
}

/* Move forward specific rotations, check for black */
void on_track(){
	int blackCount = 0;
	while(blackCount < 15){
		encoded_mforward(SMALL_TILE_DISTANCE * 2, 50);

		/* Reflected Colour */
		currentColour = SensorValue[Colour];
		if(currentColour < 15){
			blackCount++;
            playTone(200,20);
        }
	}
}




task main(){

	initial_move();
	on_track();
	encoded_rpivot(REV_90, 30);
  	encoded_mforward(SMALL_TILE_DISTANCE * 4, 50);

}
