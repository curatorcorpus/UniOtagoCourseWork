
#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Reflected) // We need to set colour Sensor to reflected light
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//=================== Basic Mathematics =================================
/*
Specifications of Robot:
Diameter of Rotation circle: 12.3 cm
Diameter of Wheel: 5.655 cm
Circumference of Rotation Circle: 38.64158964 cm
Circumference of Wheel: 17.76570646 cm
Revs in Rotation Circle: 2.175066313 revs (wheels)
Revs in 90 degree rotation: 0.5437665781 revs (wheels)
*/
//=======================================================================

//=================== Global Variables ==================================

// DEFAULLTS
#define DEFAULT_SPD 30           // default ev3 robot speed.
#define OFFSET      23           // offset for revs user defined encoded movements.
#define REV_90      0.5437665781 // exact revolutions for ev3 robot for 90 degrees.
#define REV_360     2.175066313  // exact revolutions for ev3 robot for 360 degrees.
#define SAMPLES     2         // the maximum samples we can obtain.

#define SMALL_TILE_DISTANCE 0.56 // Need to define. Based on 10cm tile

/* Motor Functions  Method used to tell both wheels to turn certain revs. */
void reset_motors(){
  setMotorSpeed(motorB, 0);
  setMotorSpeed(motorC, 0);
  sleep(10);
}
/* Method used to reset the motor encoder (turn) values. */
void reset_mencoder(){
  resetMotorEncoder(motorB);
  resetMotorEncoder(motorC);
}
/* Method for move forward given n of rotations */
void encoded_mforward(float revs, long pow){
  float revs_to_degs = revs * 360;
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, 0, revs_to_degs, pow);
  while(getMotorEncoder(motorB) <= revs_to_degs) {}
}

/* Method for pivot left given a rev and pow. */
void encoded_lpivot(float revs, long pow){
  float revs_to_degs = (revs * 360 - OFFSET);
  displayCenteredBigTextLine(4, "Rotating Left");
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, -100, revs_to_degs, pow);
  while(getMotorEncoder(motorC) <= revs_to_degs) {}
  eraseDisplay();
}

/*
  Method for pivoting right given a rev and pow.
*/
void encoded_rpivot(float revs, long pow){
  float revs_to_degs = (revs * 360 - OFFSET);
  displayCenteredBigTextLine(4, "Rotating Right");
  reset_mencoder();
  setMotorSyncEncoder(motorB, motorC, 100, revs_to_degs, pow);
  while(getMotorEncoder(motorB) <= revs_to_degs) {

  }
  eraseDisplay();
}

/* Move forward specific rotations, and rotate right */
void initial_move(){
    encoded_mforward(0.62, DEFAULT_SPD);
    encoded_rpivot(REV_90, DEFAULT_SPD);
}



/* Move forward specific rotations, check for black */
void on_track(){
	int tile_count = 0;
	int black_count = 0;

	while(black_count < 15){

		


		encoded_mforward(SMALL_TILE_DISTANCE, DEFAULT_SPD);

		/* Reflected Colour */
		current_colour = SensorValue[Colour];

		/* This should be a white tile */
		if(tile_count % 2 == 1){
			if(currentColour > 40){
				tile_count++;
			}
			else{
				displayCenteredBigTextLine(4, "Expecting White");
				displayCenteredBigTextLine(4, "Off Course");
				break;
			}
		}

		/* This should be a black tile */
		else{
			if(current_colour < 15){
				black_count++;
				tile_count++;
            	playTone(200,20);
        	}
        	else{
				displayCenteredBigTextLine(4, "Expecting Black");
				displayCenteredBigTextLine(4, "Off Course");				
				break;
        	}			
		}

		
	}
}




task main(){

	initial_move();
	on_track();
	encoded_rpivot(REV_90, DEFAULT_SPD);
  	encoded_mforward(SMALL_TILE_DISTANCE * 4, DEFAULT_SPD);

}
