#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Colours range from 0 to 7
// None    = 0
// Black   = 1
// Blue    = 2
// Green   = 3
// Yellow  = 4
// Red     = 5
// White   = 6
// Brown   = 7

void reset_motors()
{
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 0);

	sleep(10);
}

void initial_step(int initial_rot, int speed)
{
	forward(1, rotations, 50);
}

void pivot_right(){

	int speed = 30;//TODO: needs to be configured for our environment

	displayCenteredBigTextLine(4, "Rotating Right");

	setMotorSpeed(motorB, speed);
	setMotorSpeed(motorC, -speed);
	sleep(500);//TODO: needs to be configured for our environment

	eraseDisplay();
}

task thread_sonar_locator()
{

	int curr_ant_dis;

	while(true)
	{
		/*
			TODO: distance orientation correction:
			What we can do is, once the robot turns 90 degrees for sure,
			could let it travel according to black squares again. Need to check if
			the grey tiles correspond to them. because the object is 7 squares away.

			During this course, if the current distance starts decreasing, then we have
			detected an object.

			Measure difference between current and last distance reading (measure error).

			If the error is positive, then we are ok, we are heading closer to the object.
			If the error is negative, stop the robot. check both sides left and right by rotating a certain angle.
			Compare the difference between both sides.

			And pick rotation path with lowest error.

			Continue this process untill current distance get really low.
		*/

		curr_ant_dis = SensorValue[Sonar];
		displayCenteredBigTextLine(4, "Dist: %3d cm", curr_ant_dis);
	}
}

void run_stage1()
{
	int black_count = 0;
	int motor_pow = 40;

	bool on_black = false;
	bool on_dotted_line = true;

	short current_color;

	while (true)
	{

		setMotorSync(motorB, motorC, 0, motor_pow);
		current_color = SensorValue[Colour];

		// warning, if surface is too close to color sensor, the counter might iterate twice.
		if(current_color == 1) {
			if(!on_black && black_count < 15) {

				on_black = true;
				displayCenteredBigTextLine(4, "%f", ++black_count);
				playTone(700, 10);

			} else if(black_count >= 15){

				break;
			}
		} else {

			on_black = false;
		}

		sleep(100);
	}

	eraseDisplay();
}

void run_stage2()
{
	startTask(thread_sonar_locator);

	while(true)
	{

	}
}

// main task
task main()
{

	// movement parameters
	int speed = 20;
	int initial_revs = 2; //TODO: needs to be configured for our environment
/*
	// initial movement from start tile to black line
	initial_step(initial_revs, speed); // TODO: needs to be configured for our environment
	pivot_right();// TODO: needs to be configured for our environment
	reset_motors();

	// move along black line and count 15 black dots
	run_stage1();
	reset_motors();

	// rotate 90 degrees again
	pivot_right(); // TODO: needs to be configured for our environment
	reset_motors();
	*/
	run_stage2();
	reset_motors();
}
