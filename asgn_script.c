#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Colours range from 0 to 7
// None    = 0
// Black   = 1
// Blue    = 2
// Green   = 3
// Yellow  = 4
// Red     = 5
// White   = 6
// Brown   = 7

void turn_wheels(int motor_pow)
{
  motor[motorB] = motor_pow;
  motor[motorC] = motor_pow;
}

// main task
task main()
{
  int black_count = 0;
  int motor_pow = 40;
  
  bool on_track = false;
  bool hasRotated = false;
  bool toggle_black = false;
  bool toggle_start = true;
  
  nMotorEncoder[motorB] = 0;
  nMotorEncoder[motorC] = 0;

  while (true)
    {
      if(!on_track && !hasRotated)
      { 
        /* PseduoCode 
          We code the initial forward movement in distance
          We code the initial rotation
          hasRotated = true;
          onTrack = true;
        */   
      }
      
      if(on_track && hasRotated) // This equals true after first rotation
      { 
        turn_wheels(motor_pow);
        if(SensorValue[Colour] == 1)
        {
          displayCenteredBigTextLine(4, "black");
          if(!toggle_black && !toggle_start)
          {
            black_count++;
            playTone(220,500);
            toggle_black = true;
          }
        }
        else
        {
          displayCenteredBigTextLine(4, "not black");
          toggle_black = false;
          toggle_start = false;
        }
        if(black_count == 15)
        {
          on_track = false;
        }
        sleep(100); // Wait 100 ms to get 50 readings per second
      }

      if(!on_track && hasRotated)  // This equals true after second rotation
      {

      }      
    }
}
