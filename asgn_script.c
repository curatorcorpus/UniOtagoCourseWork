#pragma config(Sensor, S2,     Touch,          sensorEV3_Touch)
#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Reflected_Raw)
#pragma config(Sensor, S4,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define REV_90 0.5437665781
#define REV_360 2.175066313
#define DEFAULT_SPD 40
#define OFFSET 23

int dark = 0;
int light = 0,
long offset = 0;

long nEncoderValue = 0;

//=================== Basic Mathematics ================
/*
	Specifications of Robot:

	Diameter of Rotation circle: 12.3 cm
	Diameter of Wheel: 5.655 cm

	Circumference of Rotation Circle: 38.64158964 cm
	Circumference of Wheel: 17.76570646 cm

	Revs in Rotation Circle: 2.175066313 revs (wheels)
	Revs in 90 degree rotation: 0.5437665781 revs (wheels)
*/

//==================== Motor Operations =================
/*
	Method used to reset motor pow back to zero.
*/
void reset_motors()
{
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 0);
	sleep(10);
}

/*
	Method used to reset the motor encoder (turn) values.
*/
void reset_mencoder()
{
	resetMotorEncoder(motorB);
	resetMotorEncoder(motorC);
}

/*
	Method used to tell both wheels to turn certain revs.
*/
void encoded_mforward(float revs, long pow)
{
	float revs_to_degs = revs * 360;

	reset_mencoder();

	setMotorSyncEncoder(motorB, motorC, 0, revs_to_degs, pow);
	while(getMotorEncoder(motorB) <= revs_to_degs) {}
}

/*
	Method for pivot left given a rev and pow.
*/
void encoded_lpivot(float revs, long pow)
{
	float revs_to_degs = (revs * 360 - OFFSET);

	displayCenteredBigTextLine(4, "Rotating Left");

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, -100, revs_to_degs, pow);

	while(getMotorEncoder(motorC) <= revs_to_degs) {}
	eraseDisplay();
}

/*
	Method for pivoting right given a rev and pow.
*/
void encoded_rpivot(float revs, long pow)
{
	float revs_to_degs = (revs * 360 - OFFSET);

	displayCenteredBigTextLine(4, "Rotating Right");

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, 100, revs_to_degs, pow);

	while(getMotorEncoder(motorB) <= revs_to_degs) {}
	eraseDisplay();
}

void calc_deviation()
{
	//encoded_rpivot(50);
}

//==================== Sensor Operations ========================
/*
	Thread method used to detect distance from an object anteriorily.
*/
task thread_sonar_locator()
{
	int curr_ant_dis;

	while(true)
	{
		/*
			TODO: distance orientation correction:
			What we can do is, once the robot turns 90 degrees for sure,
			could let it travel according to black squares again. Need to check if
			the grey tiles correspond to them. because the object is 7 squares away.

			During this course, if the current distance starts decreasing, then we have
			detected an object.

			Measure difference between current and last distance reading (measure error).

			If the error is positive, then we are ok, we are heading closer to the object.
			If the error is negative, stop the robot. check both sides left and right by rotating a certain angle.
			Compare the difference between both sides.

			And pick rotation path with lowest error.

			Continue this process untill current distance get really low.
		*/

		curr_ant_dis = SensorValue[Sonar];
		displayCenteredBigTextLine(4, "Dist: %3d cm", curr_ant_dis);
	}
}

/*
task thread_whiskers()
{
	while(true)
	{
		int is_touch = SensorValue[touch];
		displayCenteredBigTextLine(4, "Bumper: %d", is_touch);
	}
}
*/

int poll_whiskers()
{
	return SensorValue[touch];
}

//==================== Calibration ============================
/*
	Method for calibrating the light dark threshold. Given 3 seconds to
	calibrate. Values range between 0 to 765.
*/
void light_calibration()
{
	int set_delay = 7000;
	int calib_delay = set_delay;
	int calib_verif_d = 3000;

	long r = 0, g= 0, b = 0;
	long sum;

	displayCenteredTextLine(4, "Light Value?");
	while(calib_delay > 0)
	{
		getColorRGB(Colour,r,g,b);
				displayCenteredTextLine(6, "r %d g %d b %d", r,g, b);
		sum = (r + g + b);
		light = sum;
		displayCenteredTextLine(1, "delay %d ", calib_delay);
		calib_delay--;
	}
	displayCenteredTextLine(4, "Light Value: %d", light);
	sleep(calib_verif_d);

	sum = 0;
	calib_delay = set_delay;

	displayCenteredTextLine(4, "Dark Value?");
	while(calib_delay > 0)
	{
		getColorRGB(Colour,r,g,b);
		displayCenteredTextLine(6, "r %d g %d b %d", r,g, b);
		sum = (r + g + b);
		dark = sum;
				displayCenteredTextLine(1, "delay %d ", calib_delay);
		calib_delay--;
	}
	displayCenteredTextLine(4, "Dark Value: %d", dark);
	sleep(calib_verif_d);

	// assumed that you calibration was given correct light and dark values.
	offset = (light + dark) / 2;

	eraseDisplay();
}

//==================== Path Correction ==================================
/*
	Method for path correction between two lines.
*/
void path_correction()
{
	int rl_correction_tgl = 1;

	long r = 0, g= 0, b = 0;
	long sum;

	while(true) // TODO: must be changed
	{
		getColorRGB(Colour,r,g,b);
		sum = (r + g + b);

		if(rl_correction_tgl == 0)
		{
			if(sum > offset)
			{

			} else
			{
				setMotorSync();
			}
		}
	}
}

/*
  int lightcount = 0; //a counter for the light sensor? or a counter used for tasks with the light sensor?

  nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;  //keep the wheels going the same speed (no unwanted turning! finally =) )
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

  nMotorEncoder[motorA] = 0;        //for turning control, probably not going to be used now..yet..maybe
  nMotorEncoder[motorB] = 0;

  while(nMotorEncoder[motorA] < 10800)  //motor A (right motor) turns 30 times before stopping
  {
     if(lightcount == 0)  //the counter starts at zero...should this be an "if" statement or a "while" statement?
     {
        if(SensorValue(lightsensor) > 49)  //light sensor reads lights object (white table)
        {
          motor[motorA] = 50;              //and so it moves forward at half speed...until...
          motor[motorB] = 50;
        }
        else                               //it hits the black line
        {
          motor[motorA] = 50;              //so it turns to the right, off of the blasck line
          motor[motorB] = -50;
          wait1Msec(350);
          lightcount = lightcount + 1;     // and adds "1" (one) to the lightcount value
        }
        if(lightcount == 1)  //now since the lightcount value is = 1, this next peice of code should run.
        {                    //should i use "if(lightcount == 1)" or "while(lightcount == 1)" here?  does it matter?
          if(SensorValue(lightsensor) > 49)
           {                                //so the light sensors reads a light value, and tells the robot to move forward
             motor[motorA] = 50;
             motor[motorB] = 50;
           }
           else                             // this time when the light sensor reads a dark value....
           {
             motor[motorA] = -50;           // it turns the opposite direction as before
             motor[motorB] = 50;
             wait1Msec(350);
             lightcount = lightcount -1;    //and reducing the lightcount value back to zero, so the first code can run again. =)
           }
        }
    }
  }
}
//conclusion:
//the robot zigzags in between the lines via two motors and one light sensor.
//going forward on a light surface and turning one way on a dark surface
//and turning the opposite way when it hits another dark surface
// comments, and helpful critic is very much appretiated
*/
//==================== Phases ==================================
/*
	Method used to travel forward from the starting tile 'S'.
*/
void initial_step()
{
	encoded_mforward(0.6, 50);//TODO: revs needs to be altered to environment.
}

/*
	Method used to move along the black dotted line and count them.
*/
void run_stage1()
{
	int black_count = 0;
	int motor_pow = 40;

	bool on_black = false;
	bool on_dotted_line = true;

	short current_color;

	while (black_count < 15)
	{
		setMotorSync(motorB, motorC, 0, motor_pow);
		current_color = SensorValue[Colour];

		// warning, if surface is too close to color sensor, the counter might iterate twice.
		if(current_color == 1)
		{
			if(!on_black && black_count < 15)
			{
				on_black = true;
				displayCenteredBigTextLine(4, "%f", ++black_count);
				playTone(700, 10);

			}

		} else on_black = false;

		sleep(100);
	}

	reset_motors();
	eraseDisplay();
}

/*
	 Method used to count the 7 grey squares + move to finishing tile 'F'.
*/
void run_stage2()
{
	//startTask(thread_sonar_locator);

	while(true)
	{
		// move forward
		displayCenteredBigTextLine(4, "Bumper: %d", poll_whiskers());
	}

	//stopTask(thread_sonar_locator);
}

//==================== MAIN ==================================
/*
	main task.
*/
task main()
{
	short rot_pow = 20;

	// light offset calibration
	light_calibration();
	// initial movement from start tile to black line
	//initial_step();

	//encoded_rpivot(REV_90, rot_pow);

	// move along black line and count 15 black dots
	//run_stage1();

	// rotate 90 degrees again
	//encoded_rpivot(REV_90, DEFAULT_SPD); // TODO: needs to be configured for our environment

	//run_stage2();
}
