#pragma config(Sensor, S2,     Touch,          sensorEV3_Touch)
#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//=================== Basic Mathematics =================================
/*
	Specifications of Robot:

		Diameter of Rotation circle: 12.3 cm
		Diameter of Wheel: 5.655 cm
		Circumference of Rotation Circle: 38.64158964 cm
		Circumference of Wheel: 17.76570646 cm
		Revs in Rotation Circle: 2.175066313 revs (wheels)
		Revs in 90 degree rotation: 0.5437665781 revs (wheels)

*/
//=======================================================================

//=================== Global Variables ==================================

// DEFAULLTS
#define DEFAULT_SPD 40           // default ev3 robot speed. working with speed of 28
#define OFFSET      23           // offset for revs user defined encoded movements.
#define REV_90      0.5437665781 // exact revolutions for ev3 robot for 90 degrees.
#define REV_360     2.175066313  // exact revolutions for ev3 robot for 360 degrees.
#define SAMPLES     2         	 // the maximum samples we can obtain.
#define ROT_POW     27           // if rot pow is too small, the encoder is not sensitive enough to detect change

bool go_left = false; // bool for path correction.

long curr_color = 0;  // obtaining current color.
long thres_l_bl   = 9; // threshold for identifying black.
long thres_h_bl   = 11;

long thres_bg = 28;
long thres_gw = 46;
//=======================================================================

//==================== Mobility Operations ==============================
/*
	Method used to reset motor pow back to zero.
*/
void reset_motors()
{
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 0);
	sleep(10);
}

/*
	Method used to reset the motor encoder (turn) values.
*/
void reset_mencoder()
{
	resetMotorEncoder(motorB);
	resetMotorEncoder(motorC);
}

/*
	Method used to tell both wheels to turn certain revs.
*/
void encoded_mforward(float revs, long pow)
{
	float revs_to_degs = revs * 360;

	reset_mencoder();

	setMotorSyncEncoder(motorB, motorC, 0, revs_to_degs, pow);
	while(getMotorEncoder(motorB) < revs_to_degs) {}
}

/*
	Method for pivot left given a rev and pow.
*/
void encoded_lpivot(float revs, long pow)
{
	float revs_to_degs = (revs * 360 - OFFSET);

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, -100, revs_to_degs, pow);

	while(getMotorEncoder(motorC) < revs_to_degs) {
		displayCenteredTextLine(2, "right %f", getMotorEncoder(motorB));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorC));
		displayCenteredTextLine(6, "cur %f", revs_to_degs);
		}
		displayCenteredTextLine(2, "right %f", getMotorEncoder(motorB));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorC));
		displayCenteredTextLine(6, "cur %f", revs_to_degs);
}

/*
	Method for pivoting right given a rev and pow.
*/
void encoded_rpivot(float revs, long pow)
{
	float revs_to_degs = (revs * 360 - OFFSET);

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, 100, revs_to_degs, pow);

	while(getMotorEncoder(motorC) > -revs_to_degs) {
				displayCenteredTextLine(2, "right %f", getMotorEncoder(motorB));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorC));
		displayCenteredTextLine(6, "cur %f", revs_to_degs);
		}
		displayCenteredTextLine(2, "right %f", getMotorEncoder(motorB));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorC));
		displayCenteredTextLine(6, "cur %f", revs_to_degs);
}
//=======================================================================

//==================== Path Correction ==================================
bool path_corrected = true;
/*
	Method for path correction, called linear backoff. If the color is wrong,
	then correct yourself by sampling your surroundings 3 times.
*/
bool linear_backoff(bool direction)
{
	bool skip_correction = true;
	float backoff_val    = 0.1;

	int pow       = 30;
	int samples   = 0;
	int n_samples = 3;

	while(samples < n_samples)
	{
		if(!direction) turnLeft( backoff_val, rotations, pow);
		else           turnRight(backoff_val, rotations, pow);

		// sample color.
		curr_color = getColorReflected(Colour);
		//curr_color = SensorValue[Colour];
		samples++;

		if(curr_color < thres_bg || thres_gw < curr_color)
		{
			displayBigTextLine(4, "l sol %d", curr_color);
			skip_correction = false;
			break;
		}
	}

	// return to original position if bad color values with offset.
	if(skip_correction)
	{
		if(!direction) turnRight(backoff_val * (samples + 1), rotations, pow);
		else           turnLeft( backoff_val * (samples + 1), rotations, pow);

		return false;
	}

	return true;
}

bool initial_check()
{
	int deg = 90;

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, 0, deg, 10);
	eraseDisplay();

	while(getMotorEncoder(motorB) < deg - 3 || getMotorEncoder(motorC) < deg - 3)
	{
		//curr_color = SensorValue[Colour];
		curr_color = getColorReflected(Colour);
			displayCenteredTextLine(2, "right %f", getMotorEncoder(motorC));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorB));
		displayCenteredTextLine(6, "cur %f", deg);
		}
		displayCenteredTextLine(2, "right %f", getMotorEncoder(motorC));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorB));
		displayCenteredTextLine(6, "cur %f", deg);

	if(curr_color < thres_bg || curr_color > thres_gw)
	{
		displayBigTextLine(4, "sol %d", curr_color);
		reset_mencoder();
		return true;
	}

	reset_mencoder();

	setMotorSyncEncoder(motorB, motorC, 0, deg, -DEFAULT_SPD);

	while(getMotorEncoder(motorB) > -deg) {}

	return false;
}

/*
	Method for path correction between two lines.
*/
void path_correction()
{
	while(!initial_check()){
		// use simple correction algorithm.
		bool corrected = linear_backoff(go_left);
		go_left = !go_left; // toggle.

		if(corrected)
		{
			path_corrected = true;
			break;
		}
	}
}
//=======================================================================

//==================== Phases ===========================================
/*
	Method used to travel forward from the starting tile 'S'.
*/
void initial_step()
{
	//encoded_mforward(0.62, 50);// hardwired example.
	encoded_mforward(0.65, DEFAULT_SPD);
}

/*
	Method used to move along the black dotted line and count them.
*/
void run_phase1()
{
	int black_count = 0;

	bool on_black = false;
	bool on_dotted_line = true;

	// filter first couple of readings

	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);
	/*
curr_color = SensorValue[Colour];
curr_color = SensorValue[Colour];
curr_color = SensorValue[Colour];
curr_color = SensorValue[Colour];
curr_color = SensorValue[Colour];
curr_color = SensorValue[Colour];*/
	while (black_count < 15)
	{
		curr_color = getColorReflected(Colour);
		//curr_color = sensorValue[Colour];

		if(thres_l_bl < curr_color && curr_color < thres_h_bl)
		//if(curr_color == 1)
		{
			if(!on_black)
			{
					on_black = true;
					//displayCenteredBigTextLine(4, "%d", ++black_count);
					++black_count;
					playTone(700, 10);

			} else if(on_black) continue;
		}

		if(thres_bg < curr_color && curr_color < thres_gw){
		//if(curr_color == 7)	{
			setMotorSync(motorB, motorC, 0, 0);
			displayCenteredBigTextLine(4, "%f", curr_color);
			path_correction();

			on_black = false;
		}

		if(path_corrected) setMotorSync(motorB, motorC, 0, DEFAULT_SPD);
	}

	reset_motors();
	//eraseDisplay();
}

/*
	Method used to count the 7 grey squares + move to finishing tile 'F'.
*/
void run_phase2()
{
	/*
	while(true)
	{
		// move forward
		displayCenteredBigTextLine(4, "Bumper: %d", poll_whiskers());
	}
	*/
}
//=======================================================================

//==================== MAIN =============================================
/*
	main task.
*/
task main()
{
	// initial movement from start tile to black line
	initial_step();

	// first right rotation
	encoded_rpivot(REV_90, ROT_POW);

	//turnRight(REV_360/4,rotations,rot_pow);

	// move along black line and count 15 black dots
	run_phase1();

	// rotate 90 degrees again
	encoded_rpivot(REV_90, ROT_POW); // TODO: needs to be configured for our environment

	//run_phase2();

}
//=======================================================================
