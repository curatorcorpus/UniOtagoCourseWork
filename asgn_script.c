#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Colours range from 0 to 7
// None    = 0
// Black   = 1
// Blue    = 2
// Green   = 3
// Yellow  = 4
// Red     = 5
// White   = 6
// Brown   = 7

void turn_wheels(int motor_pow)
{
  motor[motorB] = motor_pow;
  motor[motorC] = motor_pow;
}


void rotateRight(){
    displayCenteredBigTextLine(4, "rotating");
}

// main task
task main(){
    
  int black_count = 0;
  int motor_pow = 40;

  bool on_track = false; // can set to true to test second if
  bool hasRotated = false; // can set to true to test second if
  bool firstBlack = false;
  
  short currentColour;

  nMotorEncoder[motorB] = 0;
  nMotorEncoder[motorC] = 0;

  while (true){

      if(!on_track && !hasRotated) {
        /* PseduoCode
          We code the initial forward movement in distance
          We code the initial rotation
        */
        rotateRight();
        //on_track = true;
        //has_rotated = true;
        
      }

      if(on_track && hasRotated) { // This equals true after first rotation
            turn_wheels(motor_pow);
            currentColour = SensorValue[Colour];

            if(currentColour == 1) {
                if(!firstBlack && black_count < 15){
                         displayCenteredBigTextLine(4, "black");
                     black_count++;
                     playTone(200,20);
                     firstBlack = true;
                } else if (black_count == 15) {
                         displayCenteredBigTextLine(4, "15 reached");
                     on_track = false;
                }

            } else {
                    displayCenteredBigTextLine(4, "not");
                  firstBlack = false;
            }

            sleep(100); // Wait 100 ms to get 50 readings per second
      }

      if(!on_track && hasRotated) { // This equals true after second rotation
            displayCenteredBigTextLine(4, "rotate now");
          turn_wheels(0);
      }
   }
}