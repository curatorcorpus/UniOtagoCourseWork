#pragma config(Sensor, S2,     Touch,          sensorEV3_Touch)
#pragma config(Sensor, S3,     Colour,         sensorEV3_Color)
#pragma config(Sensor, S4,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//=================== Basic Mathematics =================================
/*
	Specifications of Robot:

		Diameter of Rotation circle: 12.3 cm
		Diameter of Wheel: 5.655 cm
		Circumference of Rotation Circle: 38.64158964 cm
		Circumference of Wheel: 17.76570646 cm
		Revs in Rotation Circle: 2.175066313 revs (wheels)
		Revs in 90 degree rotation: 0.5437665781 revs (wheels)

*/
//=======================================================================

//=================== Global Variables ==================================

// DEFAULLTS
#define DEFAULT_SPD 28           // default ev3 robot speed.
#define OFFSET      23           // offset for revs user defined encoded movements.
#define REV_90      0.5437665781 // exact revolutions for ev3 robot for 90 degrees.
#define REV_360     2.175066313  // exact revolutions for ev3 robot for 360 degrees.
#define SAMPLES     2         // the maximum samples we can obtain.

bool go_left = false; // bool for path correction.

long curr_color = 0;  // obtaining current color.
long thres_l_bl   = 9; // threshold for identifying black.
long thres_h_bl   = 12;

long thres_bg = 25;
long thres_gw = 40;
//=======================================================================

//==================== Mobility Operations ==============================
/*
	Method used to reset motor pow back to zero.
*/
void reset_motors()
{
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 0);
	sleep(10);
}

/*
	Method used to reset the motor encoder (turn) values.
*/
void reset_mencoder()
{
	resetMotorEncoder(motorB);
	resetMotorEncoder(motorC);
}

/*
	Method used to tell both wheels to turn certain revs.
*/
void encoded_mforward(float revs, long pow)
{
	float revs_to_degs = revs * 360;

	reset_mencoder();

	setMotorSyncEncoder(motorB, motorC, 0, revs_to_degs, pow);
	while(getMotorEncoder(motorB) < revs_to_degs) {}
}

/*
	Method for pivot left given a rev and pow.
*/
void encoded_lpivot(float revs, long pow)
{
	float revs_to_degs = (revs * 360 - OFFSET);

	displayCenteredBigTextLine(4, "Rotating Left");

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, -100, revs_to_degs, pow);

	while(getMotorEncoder(motorC) < revs_to_degs) {}
	eraseDisplay();
}

/*
	Method for pivoting right given a rev and pow.
*/
void encoded_rpivot(float revs, long pow)
{
	float revs_to_degs = (revs * 360 - OFFSET);

	displayCenteredBigTextLine(4, "Rotating Right");

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, 100, revs_to_degs, pow);

	while(getMotorEncoder(motorB) < revs_to_degs) {}
	eraseDisplay();
}
//=======================================================================

//==================== Path Correction ==================================
bool path_corrected = true;
/*
	Method for path correction, called linear backoff. If the color is wrong,
	then correct yourself by sampling your surroundings 3 times.
*/
void linear_backoff(bool direction)
{
	bool skip_correction = true;
	float backoff_val    = 0.1;

	int pow       = 15;
	int samples   = 0;
	int n_samples = 3;

	while(samples < n_samples)
	{
		if(!direction) turnLeft( backoff_val, rotations, pow);
		else           turnRight(backoff_val, rotations, pow);

		// sample color.
		curr_color = getColorReflected(Colour);
		samples++;

		if(curr_color < thres_bg || thres_gw < curr_color)
		{
			path_corrected = true;
			skip_correction = false;
			break;
		}
	}

	// return to original position if bad color values with offset.
	if(skip_correction)
	{
		if(!direction) turnRight(backoff_val * (samples + 1), rotations, pow);
		else           turnLeft( backoff_val * (samples + 1), rotations, pow);
	}
}

/*
	Method for path correction between two lines.
*/
void path_correction()
{
	curr_color = getColorReflected(Colour);

	if(thres_bg < curr_color && curr_color < thres_gw)
	{
		path_corrected = false;

		while(path_corrected == false){
			// use simple correction algorithm.
			linear_backoff(go_left);
			go_left = !go_left; // toggle.
		}
	}
}
//=======================================================================

//==================== Phases ===========================================
/*
	Method used to travel forward from the starting tile 'S'.
*/
void initial_step()
{
	displayCenteredBigTextLine(4, "Starting in 5 secs");
	sleep(5000);

	eraseDisplay();

	encoded_mforward(0.62, 50);// hardwired example.
	//encoded_mforward(0.65, 50);
}

/*
	Method used to move along the black dotted line and count them.
*/
void run_phase1()
{
	int black_count = 0;

	bool on_black = false;
	bool on_dotted_line = true;

	// filter first couple of readings
	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);

	while (black_count < 15)
	{
		if(!on_black)
		{
				on_black = true;
				//displayCenteredBigTextLine(4, "%d", ++black_count);
				playTone(700, 10);

		} else on_black = false;

		if(thres_bg < curr_color && curr_color < thres_gw)
			path_correction();

		if(path_corrected) setMotorSync(motorB, motorC, 0, DEFAULT_SPD);
		sleep(130);
	}

	reset_motors();
	//eraseDisplay();
}

/*
	Method used to count the 7 grey squares + move to finishing tile 'F'.
*/
void run_phase2()
{
	/*
	while(true)
	{
		// move forward
		displayCenteredBigTextLine(4, "Bumper: %d", poll_whiskers());
	}
	*/
}
//=======================================================================

//==================== MAIN =============================================
/*
	main task.
*/
task main()
{
	short rot_pow = 20;

	// initial movement from start tile to black line
	initial_step();

	// first right rotation
	// encoded_rpivot(0.55585028, rot_pow);+
	encoded_lpivot(REV_90, rot_pow);
	encoded_rpivot(REV_90, rot_pow);
	//turnRight(REV_360/4,rotations,rot_pow);

	// move along black line and count 15 black dots
	//run_phase1();

	// rotate 90 degrees again
	//encoded_rpivot(REV_90, rot_pow); // TODO: needs to be configured for our environment

	//run_phase2();

}
//=======================================================================
