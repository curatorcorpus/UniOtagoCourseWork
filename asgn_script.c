#pragma config(Sensor, S2,     Touch,          sensorEV3_Touch)
#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonar4,         sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//=================== Basic Mathematics =================================
/*
	Specifications of Robot:

		Diameter of Rotation circle: 12.3 cm
		Diameter of Wheel: 5.655 cm
		Circumference of Rotation Circle: 38.64158964 cm
		Circumference of Wheel: 17.76570646 cm
		Revs in Rotation Circle: 2.175066313 revs (wheels)
		Revs in 90 degree rotation: 0.5437665781 revs (wheels)

*/
//=======================================================================

//=================== Global Variables ==================================

// DEFAULLTS
#define DEFAULT_SPD 40           // default ev3 robot speed. working with speed of 28
#define OFFSET      23           // offset for revs user defined encoded movements.
#define REV_90      0.5437665781 // exact revolutions for ev3 robot for 90 degrees.
#define REV_360     2.175066313  // exact revolutions for ev3 robot for 360 degrees.
#define SAMPLES     2         	 // the maximum samples we can obtain.
#define ROT_POW     27           // if rot pow is too small, the encoder is not sensitive enough to detect change

bool go_left = false;            // bool for path correction.
bool path_corrected = true;      // bool for cases when path is corrected.

long curr_color = 0;             // obtaining current color.
long thres_l_bl   = 9;           // threshold for identifying black.
long thres_h_bl   = 12;          // threshold for identifying black.

long thres_bg = 28;              // default values with 28 Def_spd, 26 - 27 i think.
long thres_gw = 43;              // default values with 28 Def_spd, 44 - 46 i think.
//=======================================================================

//==================== Mobility Operations ==============================
/*
	Method used to reset motor pow back to zero.
*/
void reset_motors()
{
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 0);
	sleep(10);
}

/*
	Method used to reset the motor encoder (turn) values.
*/
void reset_mencoder()
{
	resetMotorEncoder(motorB);
	resetMotorEncoder(motorC);

	setMotorSyncEncoder(motorB, motorC, 0, 0, 0);
}

/*
	Method used to tell both wheels to turn certain revs.
*/
void encoded_mforward(float revs, long pow)
{
	float revs_to_degs = revs * 360;

	reset_mencoder();

	setMotorSyncEncoder(motorB, motorC, 0, revs_to_degs, pow);
	while(getMotorEncoder(motorB) < revs_to_degs) {}
}

/*
	Method for pivot left given a rev and pow.
*/
void encoded_lpivot(float revs, long pow)
{
	float revs_to_degs = (revs * 360 - OFFSET);

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, -100, revs_to_degs, pow);

	while(getMotorEncoder(motorC) < revs_to_degs) {
		displayCenteredTextLine(2, "right %f", getMotorEncoder(motorB));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorC));
		displayCenteredTextLine(6, "cur %f", revs_to_degs);
		}
		displayCenteredTextLine(2, "right %f", getMotorEncoder(motorB));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorC));
		displayCenteredTextLine(6, "cur %f", revs_to_degs);
}

/*
	Method for pivoting right given a rev and pow.
*/
void encoded_rpivot(float revs, long pow)
{
	float revs_to_degs = (revs * 360 - OFFSET);

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, 100, revs_to_degs, pow);

	while(getMotorEncoder(motorC) > -revs_to_degs) {
				displayCenteredTextLine(2, "right %f", getMotorEncoder(motorB));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorC));
		displayCenteredTextLine(6, "cur %f", revs_to_degs);
		}
		displayCenteredTextLine(2, "right %f", getMotorEncoder(motorB));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorC));
		displayCenteredTextLine(6, "cur %f", revs_to_degs);
}
//=======================================================================

//==================== Path Correction ==================================
/*
	Method for path correction, called linear backoff. If the color is wrong,
	then correct yourself by sampling your surroundings 3 times.
*/
bool linear_backoff(bool direction)
{
	bool skip_correction = true;
	float backoff_val    = 0.1;

	int pow       = 30;
	int samples   = 0;
	int n_samples = 3;

	while(samples < n_samples)
	{
		if(!direction) turnLeft( backoff_val, rotations, pow);
		else           turnRight(backoff_val, rotations, pow);

		// sample color.
		curr_color = getColorReflected(Colour);
		//curr_color = SensorValue[Colour];
		samples++;

		if(curr_color < thres_bg || thres_gw < curr_color)
		{
			displayBigTextLine(4, "l sol %d", curr_color);
			skip_correction = false;
			break;
		}
	}

	// return to original position if bad color values with offset.
	if(skip_correction)
	{
		if(!direction) turnRight(backoff_val * (samples + 1), rotations, pow);
		else           turnLeft( backoff_val * (samples + 1), rotations, pow);

		return false;
	}

	return true;
}

bool initial_check()
{
	int deg = 90;

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, 0, deg, 10);
	eraseDisplay();

	while(getMotorEncoder(motorB) < deg - 4 || getMotorEncoder(motorC) < deg - 4)
	{
		curr_color = getColorReflected(Colour);
			displayCenteredTextLine(2, "right %f", getMotorEncoder(motorC));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorB));
		displayCenteredTextLine(6, "cur %f", deg);
		}
		displayCenteredTextLine(2, "right %f", getMotorEncoder(motorC));
		displayCenteredTextLine(4, "left %f", getMotorEncoder(motorB));
		displayCenteredTextLine(6, "cur %f", deg);

	if(curr_color < thres_bg || curr_color > thres_gw)
	{
		displayBigTextLine(4, "sol %d", curr_color);
		reset_mencoder();
		return true;
	}

	reset_mencoder();

	setMotorSyncEncoder(motorB, motorC, 0, deg, -DEFAULT_SPD);

	while(getMotorEncoder(motorB) > -deg) {}

	return false;
}

/*
	Method for path correction between two lines.
*/
void path_correction()
{
	while(!initial_check()){
		// use simple correction algorithm.
		bool corrected = linear_backoff(go_left);
		go_left = !go_left; // toggle.

		if(corrected)
		{
			path_corrected = true;
			break;
		}
	}
}
//=======================================================================

//==================== Phases ===========================================
/*
	Method used to travel forward from the starting tile 'S'.
*/
void initial_step()
{
	//encoded_mforward(0.62, 50);// hardwired example.
	encoded_mforward(0.65, DEFAULT_SPD);
}

/*
	Method used to move along the black dotted line and count them.
*/
void move_along_bw_tiles()
{
	int black_count = 0;

	bool passed_black = false;
	bool tgl_black = false;

	// filter first couple of readings
	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);
	curr_color = getColorReflected(Colour);

	while (black_count < 15)
	{
		curr_color = getColorReflected(Colour);

		if(thres_l_bl < curr_color && curr_color < thres_h_bl)
		{
			//tgl_black = true;

			if(!tgl_black)
			{
					tgl_black = true;
					++black_count;
					playTone(700, 15);

			} else if(tgl_black) continue;

		}

		if(thres_bg < curr_color && curr_color < thres_gw){
			setMotorSync(motorB, motorC, 0, 0);
			displayCenteredBigTextLine(4, "%f", curr_color);
			path_correction();

			tgl_black = false;
			//passed_black = false;

			//if(thres_l_bl < curr_color && curr_color < thres_h_bl)
		}
		/*
		if(tgl_black)
		{
			continue;
			if(!passed_black)
			{
				passed_black = true;
				++black_count;
				playTone(700, 15);
			}
		} */

		if(path_corrected) setMotorSync(motorB, motorC, 0, DEFAULT_SPD);

		// insert sleep/delay to slow down path correction -> i think.
	}

	reset_mencoder();
	reset_motors();
}

/*
	Method used to count the 7 grey squares + move to finishing tile 'F'.
*/
void run_phase2()
{
int distances[10];
 /* rotate left  90 */
 turnLeft(REV_90, rotations, 30);


/*
 Incrementally pivot and store the sensor Value at each increment
 */
 for(int i = 0; i < 10; i++){
   turnRight(REV_360/20, rotations, 30);
   sleep(50);
   distances[i] = SensorValue[sonar4];
   displayCenteredBigTextLine(4, "Distance: %d", distances[i]);
   displayCenteredBigTextLine(6, "Key: %d", i );
   sleep(200);
 }

int lowestValue = 0;
 int lowestKey = 0;

/* Iterate through array, checking for lowestDistance */
 for(int i = 0; i < 10; i++){
   if(i == 0){
     lowestKey = i;
     lowestValue = distances[i];
   }
   else if( distances[i] < lowestValue){
     lowestKey = i;
     lowestValue = distances[i];
   }
 }

 lowestKey++;
eraseDisplay();
displayCenteredBigTextLine(4, "lowestValue %f", lowestValue);

float turnTo = (REV_360/2 / 10.00) * (10.00 - lowestKey);
 /*
 Specifications of Robot:
 Diameter of Rotation circle: 12.3 cm
 Diameter of Wheel: 5.655 cm
 Circumference of Rotation Circle: 38.64158964 cm
 Circumference of Wheel: 17.76570646 cm
 Revs in Rotation Circle: 2.175066313 revs (wheels)
 Revs in 90 degree rotation: 0.5437665781 revs (wheels)
 */
 turnLeft(turnTo , rotations, 30);

/* This will stop just before the tower */
 encoded_mforward(lowestValue/40, 30);
}
//=======================================================================

//==================== MAIN =============================================
/*
	main task.
*/
task main()
{
	// initial movement from start tile to black line
	initial_step();

	// first right rotation
	encoded_rpivot(REV_90, ROT_POW);

	// move along black line and count 15 black dots
	move_along_bw_tiles();

	// rotate 90 degrees again
	encoded_rpivot(REV_90, ROT_POW); // TODO: needs to be configured for our environment

	encoded_mforward(6, 60);

	run_phase2();
}
//=======================================================================
