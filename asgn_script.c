#pragma config(Sensor, S2,     Touch,          sensorEV3_Touch)
#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Reflected_Raw)
#pragma config(Sensor, S4,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define REV_90 0.5437665781
#define REV_360 2.175066313
#define DEFAULT_SPD 40
#define OFFSET 23

//=================== Basic Mathematics ================
/*
	Specifications of Robot:

	Diameter of Rotation circle: 12.3 cm
	Diameter of Wheel: 5.655 cm

	Circumference of Rotation Circle: 38.64158964 cm
	Circumference of Wheel: 17.76570646 cm

	Revs in Rotation Circle: 2.175066313 revs (wheels)
	Revs in 90 degree rotation: 0.5437665781 revs (wheels)
*/

//==================== Motor Operations =================
/*
	Method used to reset motor pow back to zero.
*/
void reset_motors()
{
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 0);
	sleep(100);
}

/*
	Method used to reset the motor encoder (turn) values.
*/
void reset_mencoder()
{
	resetMotorEncoder(motorB);
	resetMotorEncoder(motorC);
	sleep(100);
}

/*
	Method used to tell both wheels to turn certain revs.
*/
void encoded_mforward(float revs, long pow)
{
	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, 0, ((revs * 360) + 1), pow); // plus 1 to compensate rounding error
	sleep(1000 * revs);
}

/*
	Method for pivoting right given a rev and pow.
*/
void encoded_rpivot(float revs, long pow)
{
	float divisor  = (pow / 10);
	float duration = 10000 * 1 / divisor;

	displayCenteredBigTextLine(4, "Rotating Right");

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, 100, (revs * 360 - OFFSET), pow); // plus 1 to compensate rounding error
	sleep(duration); //TODO: Duration needs to be fixed - ideally, faster speed, less duration.

	reset_mencoder();
	eraseDisplay();
}

void encoded_lpivot(float revs, long pow)
{
	float divisor  = (pow / 10);
	float duration = 10000 * 1 / divisor;

	displayCenteredBigTextLine(4, "Rotating Right");

	reset_mencoder();
	setMotorSyncEncoder(motorB, motorC, -100, (revs * 360 - OFFSET), pow); // plus 1 to compensate rounding error
	sleep(duration); //TODO: Duration needs to be fixed - ideally, faster speed, less duration.

	reset_mencoder();
	eraseDisplay();
}

void calc_deviation()
{
	encoded_rpivot(,50);
}

//==================== Sensor Operations ========================
/*
	Thread method used to detect distance from an object anteriorily.
*/
task thread_sonar_locator()
{
	int curr_ant_dis;

	while(true)
	{
		/*
			TODO: distance orientation correction:
			What we can do is, once the robot turns 90 degrees for sure,
			could let it travel according to black squares again. Need to check if
			the grey tiles correspond to them. because the object is 7 squares away.

			During this course, if the current distance starts decreasing, then we have
			detected an object.

			Measure difference between current and last distance reading (measure error).

			If the error is positive, then we are ok, we are heading closer to the object.
			If the error is negative, stop the robot. check both sides left and right by rotating a certain angle.
			Compare the difference between both sides.

			And pick rotation path with lowest error.

			Continue this process untill current distance get really low.
		*/

		curr_ant_dis = SensorValue[Sonar];
		displayCenteredBigTextLine(4, "Dist: %3d cm", curr_ant_dis);
	}
}

task thread_path_correction()
{
	long r,g,b;
	long sum;

	while(true){

		getColorRGB(Colour,r,g,b);
		sum = r + g + b;

		// supposedly it is not white or black tiles.
		if(40 < sum && sum < 130)
		{
			calc_deviation();
		}

	}
}

/*
task thread_whiskers()
{
	while(true)
	{
		int is_touch = SensorValue[touch];
		displayCenteredBigTextLine(4, "Bumper: %d", is_touch);
	}
}
*/

int poll_whiskers()
{
	return SensorValue[touch];
}

//==================== Phases ==================================
/*
	Method used to travel forward from the starting tile 'S'.
*/
void initial_step()
{
	//forward(1, rotations, 50);
	encoded_mforward(3, 50);//TODO: revs needs to be altered to environment.
	reset_mencoder();
}

/*
	Method used to move along the black dotted line and count them.
*/
void run_stage1()
{
	int black_count = 0;
	int motor_pow = 40;

	bool on_black = false;
	bool on_dotted_line = true;

	short current_color;

	while (true)
	{
		setMotorSync(motorB, motorC, 0, motor_pow);
		current_color = SensorValue[Colour];

		// warning, if surface is too close to color sensor, the counter might iterate twice.
		if(current_color == 1)
		{
			if(!on_black && black_count < 15)
			{

				on_black = true;
				displayCenteredBigTextLine(4, "%f", ++black_count);
				playTone(700, 10);

			} else if(black_count >= 15) break;

		} else on_black = false;

		sleep(100);
	}

	reset_motors();
	eraseDisplay();
}

/*
	 Method used to count the 7 grey squares + move to finishing tile 'F'.
*/
void run_stage2()
{
	//startTask(thread_sonar_locator);

	while(true)
	{
		// move forward
		displayCenteredBigTextLine(4, "Bumper: %d", poll_whiskers());
	}

	//stopTask(thread_sonar_locator);
}

//==================== MAIN ==================================
/*
	main task.
*/
task main()
{
	// initial movement from start tile to black line
	//initial_step();

	//initial_step(); // TODO: needs to be configured for our environment
	//encoded_rpivot(REV_90, DEFAULT_SPD);

	// move along black line and count 15 black dots
	//run_stage1();

	// rotate 90 degrees again
	//encoded_rpivot(REV_90, DEFAULT_SPD); // TODO: needs to be configured for our environment

	//run_stage2();
}
