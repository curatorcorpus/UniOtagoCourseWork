#pragma config(Sensor, S4,     sonar4,         sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Reflected) // We need to set colour Sensor to reflected light
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define DEFAULT_SPD 30           // default ev3 robot speed.
#define OFFSET      23           // offset for revs user defined encoded movements.
#define REV_90      0.5437665781 // exact revolutions for ev3 robot for 90 degrees.
#define REV_360     2.175066313
#define REV_180     1.0875331565  // exact revolutions for ev3 robot for 360 degrees.
#define SAMPLES     2         // the maximum samples we can obtain.

void reset_mencoder(){
    resetMotorEncoder(motorB);
    resetMotorEncoder(motorC);
}

void encoded_mforward(float revs, long pow){
    float revs_to_degs = revs * 360;
    reset_mencoder();
    setMotorSyncEncoder(motorB, motorC, 0, revs_to_degs, pow);
    while(getMotorEncoder(motorB) <= revs_to_degs) {}
}

void encoded_lpivot(float revs, long pow){
    float revs_to_degs = (revs * 360 - OFFSET);
    //displayCenteredBigTextLine(4, "Rotating Left");
    reset_mencoder();
    setMotorSyncEncoder(motorB, motorC, -100, revs_to_degs, pow);
    while(getMotorEncoder(motorC) <= revs_to_degs) {}
    //eraseDisplay();
}

/*
Method for pivoting right given a rev and pow.
*/
void encoded_rpivot(float revs, long pow){
    float revs_to_degs = (revs * 360 - OFFSET);
    //displayCenteredBigTextLine(4, "Rotating Right");
    reset_mencoder();
    setMotorSyncEncoder(motorB, motorC, 100, revs_to_degs, pow);
    while(getMotorEncoder(motorB) <= revs_to_degs) {}
    //eraseDisplay();
}

task main()
{
  int distances[10];

  /* rotate left  90 */
  turnLeft(REV_90, rotations, 30);

  /* 
  Incrementally pivot and store the sensor Value at each increment
  */
  for(int i = 0; i <= 10; i++){
    turnRight(REV_180/10, rotations, 30);
    distances[i] = SensorValue[sonar4];
  }

  int lowestValue = 0;
  int lowestKey = 0; 

  /* Iterate through array, checking for lowestDistance */
  for(int i = 0; i < 10; i++){
    if(i == 0){
      lowestValue = distances[i];
    }
    else if( distances[i] < lowestValue){
      lowestKey = i;
      lowestValue = distance[i + 1];
    }
  }  
  /*
  Specifications of Robot:
  Diameter of Rotation circle: 12.3 cm
  Diameter of Wheel: 5.655 cm
  Circumference of Rotation Circle: 38.64158964 cm
  Circumference of Wheel: 17.76570646 cm
  Revs in Rotation Circle: 2.175066313 revs (wheels)
  Revs in 90 degree rotation: 0.5437665781 revs (wheels)
  */
  turnLeft(REV_180/10*(10 - lowestKey), rotations, 30);
  
  /* This will stop just before the tower */
  encoded_mforward(lowestValue/40, 30);

  }
}