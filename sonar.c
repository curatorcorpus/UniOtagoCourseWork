#pragma config(Sensor, S4,     sonar4,         sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define DEFAULT_SPD 30           // default ev3 robot speed.
#define OFFSET      23           // offset for revs user defined encoded movements.
#define REV_90      0.5437665781 // exact revolutions for ev3 robot for 90 degrees.
#define REV_360     2.175066313  // exact revolutions for ev3 robot for 360 degrees.
#define SAMPLES     2         // the maximum samples we can obtain.

void reset_mencoder(){
    resetMotorEncoder(motorB);
    resetMotorEncoder(motorC);
}

void encoded_mforward(float revs, long pow){
    float revs_to_degs = revs * 360;
    reset_mencoder();
    setMotorSyncEncoder(motorB, motorC, 0, revs_to_degs, pow);
    while(getMotorEncoder(motorB) <= revs_to_degs) {}
}

void encoded_lpivot(float revs, long pow){
    float revs_to_degs = (revs * 360 - OFFSET);
    //displayCenteredBigTextLine(4, "Rotating Left");
    reset_mencoder();
    setMotorSyncEncoder(motorB, motorC, -100, revs_to_degs, pow);
    while(getMotorEncoder(motorC) <= revs_to_degs) {}
    //eraseDisplay();
}

/*
Method for pivoting right given a rev and pow.
*/
void encoded_rpivot(float revs, long pow){
    float revs_to_degs = (revs * 360 - OFFSET);
    //displayCenteredBigTextLine(4, "Rotating Right");
    reset_mencoder();
    setMotorSyncEncoder(motorB, motorC, 100, revs_to_degs, pow);
    while(getMotorEncoder(motorB) <= revs_to_degs) {}
    //eraseDisplay();
}

task main()
{
	int currentDistance = 0;
	
	int rightEdgeDistance = 0;
	int leftEdgeDistance = 0;
	bool measureRight = true;
	bool measureLeft = false;
	bool findMidPoint = false;
	
	encoded_rpivot(REV_90, DEFAULT_SPD);
	encoded_mforward(1, DEFAULT_SPD);

	while(true)
	{
		// Read the sensor
		currentDistance = SensorValue[sonar4];
		displayCenteredBigTextLine(4, "Dist: %3d cm", currentDistance);
		displayCenteredBigTextLine(7, "Dist: %3d cm", rightEdgeDistance);
		displayCenteredBigTextLine(9, "Dist: %3d cm", leftEdgeDistance);
		
		while(measureRight){
			if(currentDistance < 250){
				encoded_rpivot(REV_360/360, 5);
				rightEdgeDistance = currentDistance;
			}else{
				measureLeft = true;
				measureRight = false;
				reset_mencoder();
				break;
			}
		}
		
		while(measureLeft){
			if(currentDistance < 250){
				encoded_lpivot(REV_360/360, 5);
				leftEdgeDistance = currentDistance;
			}else{
				findMidPoint = true;
				measureLeft = false;
				break;
			}
		}
		
		if(findMidPoint){
			playTone(200, 20);
			//encoded_rpivot(getMotorEncoder(motorB)/2, 5);
		}
	

		/*// We're too far away, move forward
		if ((distanceToMaintain - currentDistance) < -2)
		{
			motor[motorLeft] = 30;
			motor[motorRight] = 30;
		}
		// We're too close, move backwards
		else if ((distanceToMaintain - currentDistance) > 2)
		{
			motor[motorLeft] = -30;
			motor[motorRight] = -30;
		}
		// We're good, don't go anywhere
		else
		{
			motor[motorLeft] = 0;
			motor[motorRight] = 0;
		}*/

		//Loop to monitor value in Sensor debugger window
	}
}
